<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>transformer学习</title>
      <link href="/2022/10/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/transformer%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/transformer%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Transformer详解"><a href="#Transformer详解" class="headerlink" title="Transformer详解"></a>Transformer详解</h1><p>（整篇笔记为博客学习<a href="https://blog.csdn.net/longxinchen_ml/article/details/86533005%EF%BC%89">https://blog.csdn.net/longxinchen_ml/article/details/86533005）</a></p><p><strong>名词解释：</strong></p><ul><li>SOTA<ul><li>State of The Art  指在该项研究任务中，对比该领域的其他模型，这个是目前最好、最先进的模型。</li></ul></li></ul><p><strong>文献阅读：</strong></p><ul><li>Transformer模型提出的原始论文：Attention is All You Need: <a href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a></li></ul><h1 id="一、基础入门整体架构"><a href="#一、基础入门整体架构" class="headerlink" title="一、基础入门整体架构"></a>一、基础入门整体架构</h1><h2 id="1-从宏观开始看"><a href="#1-从宏观开始看" class="headerlink" title="1.从宏观开始看"></a><strong>1.从宏观开始看</strong></h2><ul><li>将这个模型看成一个黑箱操作，或者一个函数，机器。以机器翻译为例，当输入一个语言时，通过模型的一系列加工，得到的输出是另一种语言。</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201528268.png" alt="image-20221020152520946"></p><h2 id="2-各模块拆分详解"><a href="#2-各模块拆分详解" class="headerlink" title="2.各模块拆分详解"></a><strong>2.各模块拆分详解</strong></h2><ul><li>1.详细一步，看中间transformer结构，发现它由编码结构和解码结构以及两者之间的连接构成。</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201535751.png" alt="image-20221020153505554"></p><ul><li>2.进一步分析，论文介绍，编码组件和解码组件均分别用的6层的编码器和解码器组成。</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201536752.png" alt="image-20221020153649254"></p><ul><li>3.每一个编码器在结构上都是相同的，解码器也一样。下面看单个编码器的内部结构，如下图所示。</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201601723.png" alt="image-20221020160144481"></p><p>当翻译语句输入序列从编码器进行输入时，首先会经过一个自注意力层，这层会帮助编码器注意到其他信息。</p><p>自注意力层输出后，进入前馈神经网络。每个位置的单词对应的前馈神经网络都完全一样</p><ul><li>下面看一下解码器。和编码器结构类似，除了编码器具有的两层机制外，在两层中间还有一个注意力层，用来关注输入句子的相关部分</li></ul><h1 id="二、进阶"><a href="#二、进阶" class="headerlink" title="二、进阶"></a>二、进阶</h1><h2 id="1-引入张量"><a href="#1-引入张量" class="headerlink" title="1.引入张量"></a>1.引入张量</h2><p>在模型输入时，一些输入的均是词向量，（简单说只有转化成数字才能进行一些列运算）</p><ul><li>首先将每个单词通过词嵌入算法（如word2vec）转化为词向量，如下图所示</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201617242.png" alt="image-20221020161718124"></p><p>每个单词都转化为512维度的向量，上图用简单方框来表示这些向量。</p><ul><li>接着将词向量序列输入编码器之后，会经过编码器的两个子层</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201628180.png" alt="image-20221020162810745"></p><p>接下来我们看看Transformer的一个核心特性，在这里输入序列中<strong>每个位置的单词都有自己独特的路径流入编码器</strong>。在自注意力层中，这些路径之间存在依赖关系。而前馈（feed-forward）层没有这些依赖关系。因此在前馈（feed-forward）层时可以并行执行各种路径。</p><h2 id="2-开始编码"><a href="#2-开始编码" class="headerlink" title="2.开始编码"></a>2.开始编码</h2><p><strong>基本流程：</strong>一个编码器接收向量列表作为输入，接着将向量列表中的向量传递到自注意力层进行处理，然后传递到前馈神经网络层中，将输出结果传递到下一个编码器中。</p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201631694.png" alt="image-20221020163102918"></p><p>输入序列的每个单词都经过自编码过程。然后，他们各自通过前向传播神经网络——完全相同的网络，而每个向量都分别通过它。</p><h1 id="三、自注意力机制"><a href="#三、自注意力机制" class="headerlink" title="三、自注意力机制"></a>三、自注意力机制</h1><h2 id="1-从宏观视角看自注意力机制"><a href="#1-从宏观视角看自注意力机制" class="headerlink" title="1.从宏观视角看自注意力机制"></a>1.从宏观视角看自注意力机制</h2><p><strong>对于自注意力机制的理解：</strong></p><p>以下列我们想要翻译的句子为例：</p><ul><li>The animal didn’t cross the street because it was too tired。</li></ul><p>这里的it时指的animal还是street呢，人很容易判断，但是计算机算法则不然。而使用自注意力机制会帮助it与animal建立联系。</p><p>随着模型处理输入序列的每个单词，自注意力会关注整个输入序列的所有单词，帮助模型对本单词更好地进行编码。</p><p><strong>与RNN作对比：</strong></p><ul><li>RNN会将它已经处理过的前面的所有单词&#x2F;向量的表示与它正在处理的当前单词&#x2F;向量结合起来。  有一个ht-1的隐藏状态</li><li>而自注意力机制会将所有相关单词的理解融入到我们正在处理的单词中。</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201642298.png" alt="image-20221020164226152"></p><p>当我们在最后一个编码器编码“it”这个单词的时，注意力机制的部分会去关注“The Animal”，将它的表示的一部分编入“it”的编码中。</p><h2 id="2-从微观视角看注意力机制"><a href="#2-从微观视角看注意力机制" class="headerlink" title="2.从微观视角看注意力机制"></a>2.从微观视角看注意力机制</h2><p><strong>1）首先由最开始的词嵌入向量得到 q k v三个向量</strong></p><ul><li>计算自注意力的<strong>第一步</strong>就是从每个编码器的输入向量（每个单词的词向量）中生成三个向量。查询向量、一个键向量和一个值向量。这三个向量是通过词嵌入与三个权重矩阵后相乘创建的。如图所示。</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201649145.png" alt="image-20221020164903514"></p><ul><li>可以发现这些新向量在维度上比词嵌入向量更低。他们的维度是64，而词嵌入和编码器的输入&#x2F;输出向量的维度是512. 但实际上不强求维度更小，这只是一种基于架构上的选择，它可以使多头注意力（multiheaded attention）的大部分计算保持不变。</li></ul><p><strong>注：</strong>从上图中理解，以x1词嵌入向量为例。X1是1x4的矩阵，而WQ权重矩阵是4x3的矩阵，两者相乘得到的q1向量为1x3维的向量。其他向量也是如此得到</p><p>经过这个步骤，就得到了 三个不同的向量</p><p><strong>2）那么什么是查询向量、键向量和值向量呢</strong></p><ul><li>计算自注意力的第二步是计算得分。假设我们在为这个例子中的第一个词“Thinking”计算自注意力向量，我们需要拿输入句子中的每个单词对“Thinking”打分。这些分数决定了在编码单词“Thinking”的过程中有多重视句子的其它部分。</li><li>这些分数是通过打分单词（所有输入句子的单词）的键向量与“Thinking”的查询向量相点积来计算的。所以如果我们是处理位置最靠前的词的自注意力的话，第一个分数是q1和k1的点积，第二个分数是q1和k2的点积。</li></ul><p>注：当针对第一个单词时，会用本单词的q1与句子中所有单词的k进行乘积，得到一个数值-分数。</p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201719995.png" alt="image-20221020171654860"></p><ul><li>第三步和第四步是将分数除以8(8是论文中使用的键向量的维数64的平方根，这会让梯度更稳定。即论文中根号下V，然后通过softmax传递结果。softmax的作用是使所有单词的分数归一化，得到的分数都是正值且和为1。</li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221020172136500.png" alt="image-20221020172136500"></p><p>这个softmax分数决定了每个单词对编码当下位置（“Thinking”）的贡献。显然，已经在这个位置上的单词将获得最高的softmax分数，但有时关注另一个与当前单词相关的单词也会有帮助。</p><ul><li><p>第五步是将每个值向量乘以softmax分数(这是为了准备之后将它们求和)。这里的直觉是希望关注语义上相关的单词，并弱化不相关的单词(例如，让它们乘以0.001这样的小数)。</p></li><li><p>第六步是对加权值向量求和（译注：自注意力的另一种解释就是在编码某个单词时，就是将所有单词的表示（值向量）进行加权求和，而权重是通过该词的表示（键向量）与被编码词表示（查询向量）的点积并通过softmax得到。），然后即得到自注意力层在该位置的输出(在我们的例子中是对于第一个单词)。</p></li></ul><p><img src="https://github.com/zikers/image_store/blob/main/img/202210201749430.png?raw=true" alt="image-20221020172421834"></p><p>这样自注意力的计算就完成了。得到的向量就可以传给前馈神经网络。然而实际中，这些计算是以矩阵形式完成的，以便算得更快。那我们接下来就看看如何用矩阵实现的。</p><h2 id="3-矩阵运算实现自注意力机制"><a href="#3-矩阵运算实现自注意力机制" class="headerlink" title="3.矩阵运算实现自注意力机制"></a>3.矩阵运算实现自注意力机制</h2><ul><li>第一步是计算查询矩阵、键矩阵和值矩阵。为此，我们将将输入句子的词嵌入装进矩阵X中，将其乘以我们训练的权重矩阵(WQ，WK，WV)。</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201736840.png" alt="image-20221020173253809"></p><ul><li>x矩阵中的每一行对应于输入句子中的一个单词。</li><li>最后，由于我们处理的是矩阵，我们可以将步骤2到步骤6合并为一个公式来计算自注意力层的输出。</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210201735879.png" alt="image-20221020173425317"></p><p>注：这里的三个权重矩阵是共用的</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2022/10/14/git/"/>
      <url>/2022/10/14/git/</url>
      
        <content type="html"><![CDATA[<h1 id="一、版本控制"><a href="#一、版本控制" class="headerlink" title="一、版本控制"></a>一、版本控制</h1><h2 id="1-什么是版本控制？"><a href="#1-什么是版本控制？" class="headerlink" title="1. 什么是版本控制？"></a>1. 什么是版本控制？</h2><ul><li>是一种在开发过程中用于管理我们的文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</li></ul><h2 id="2-用途"><a href="#2-用途" class="headerlink" title="2. 用途"></a>2. 用途</h2><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单的说，就是用于管理多人开发协同开发项目的技术。</p><h2 id="3-常见版本控制工具"><a href="#3-常见版本控制工具" class="headerlink" title="3. 常见版本控制工具"></a>3. 常见版本控制工具</h2><ul><li>Git</li><li>SVN</li><li>CVS</li><li>VSS</li><li>TFS</li><li>Visual Studio Online</li></ul><h2 id="4-版本控制分类"><a href="#4-版本控制分类" class="headerlink" title="4.版本控制分类"></a>4.版本控制分类</h2><p>1）本地版本控制</p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210141400430.png" alt="image-20221014140030680"></p><p>2）集中版本控制</p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210141400781.png" alt="image-20221014140043610"></p><p>3）分布式版本控制</p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210141400260.png" alt="image-20221014140053685"></p><h1 id="二、Git历史"><a href="#二、Git历史" class="headerlink" title="二、Git历史"></a>二、Git历史</h1><p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p><h1 id="三、Git环境配置"><a href="#三、Git环境配置" class="headerlink" title="三、Git环境配置"></a>三、Git环境配置</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>安装好后，如图所示。</p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210141409233.png" alt="image-20221014140915068"></p><ul><li><p><strong>Git Bash：</strong>Unix与Linux风格的命令行，使用最多，推荐最多</p></li><li><p><strong>Git CMD：</strong>Windows风格的命令行</p></li><li><p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p></li></ul><h2 id="2-Git配置"><a href="#2-Git配置" class="headerlink" title="2.Git配置"></a>2.Git配置</h2><ul><li>查看配置 git config -l</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210141415581.png" alt="image-20221014141551875"></p><ul><li>查看不同级别的配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看系统config</span><br>git config --system --list<br><span class="hljs-meta prompt_">　　</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看当前用户（global）配置</span><br>git config --global  --list<br></code></pre></td></tr></table></figure><ul><li><strong>Git相关的配置文件：</strong></li></ul><p>1）Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p><p>2）C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  –global 全局</p><p><strong>注：</strong>所有配置文件其实都保存在本地。用命令修改配置之后，其实就是改变了文件内容。也可以打开文件进行修改。</p><ul><li>设置用户名与邮箱</li></ul><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;kuangshen&quot;  #名称git config --global user.email 24736743@qq.com   #邮箱<br></code></pre></td></tr></table></figure><h1 id="四、Git基本理论（核心）"><a href="#四、Git基本理论（核心）" class="headerlink" title="四、Git基本理论（核心）"></a>四、Git基本理论（核心）</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西瓜书错题记录</title>
      <link href="/2022/10/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A5%BF%E7%93%9C%E4%B9%A6%E9%94%99%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/10/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%A5%BF%E7%93%9C%E4%B9%A6%E9%94%99%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="二、模型评估与选择"><a href="#二、模型评估与选择" class="headerlink" title="二、模型评估与选择"></a>二、模型评估与选择</h1><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210140956951.png" alt="image-20221014095603109"></p><p><strong>解析：</strong></p><p>三个关键问题：</p><ul><li>如何获得测试结果？（怎么得到测试集，得到“未来的数据”）—–评估方法<ul><li>留出法</li><li>交叉验证法</li><li>自助法</li></ul></li><li>如何评估性能优劣？ ——–性能度量 <ul><li>错误度与精度</li><li>查准率、查全率与F1</li><li>ROC与AUC</li></ul></li><li>如何判断实质差别？ ——–比较检验</li></ul><p>这篇博客讲的很细：</p><ul><li><a href="https://www.pythonheidong.com/blog/article/1212198/c7c2dbdef8c155677aa9/">https://www.pythonheidong.com/blog/article/1212198/c7c2dbdef8c155677aa9/</a> 机器学习入门之模型评估与选择</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210141023542.png" alt="image-20221014102323680"></p><p><strong>解析：</strong></p><ul><li><p>模型根据数据自动学习出的变量，就是<strong>参数</strong>。比如，深度学习的权重，偏差等。</p></li><li><p><strong>超参数</strong>一般是根据经验确定的变量，用来确定模型的一些参数，超参数不同，模型是不同的。在深度学习中，超参数有：学习速率（lr），迭代次数，层数，每层神经元的个数等等。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注意力机制</title>
      <link href="/2022/10/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/10/11/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="注意力机制详解"><a href="#注意力机制详解" class="headerlink" title="注意力机制详解"></a>注意力机制详解</h1><h1 id="一、注意力机制介绍"><a href="#一、注意力机制介绍" class="headerlink" title="一、注意力机制介绍"></a>一、注意力机制介绍</h1><p>什么是注意力：</p><ul><li>我们在观察事物时，之所以能够快速判断一种事物，是因为我们大脑能够把注意力放在事物最具有辨识度的部分而做出判断，而不是从头到尾观察事物之后，才能有判断结果。正是基于这样的理论，产生了注意力机制。</li></ul><p>什么是注意力计算规则：</p><ul><li>有三个指定的输入，Q(query),K(key),V(value)。然后通过公式得到注意力的计算结果。这个结果代表了query在key和value下的表示。</li><li>一种计算规则如图所示</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210122117004.png" alt="image-20221012211747539"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformer详解</title>
      <link href="/2022/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Transformer%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/10/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Transformer%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Transformer详解"><a href="#Transformer详解" class="headerlink" title="Transformer详解"></a>Transformer详解</h1><h1 id="一、transformer整体框架"><a href="#一、transformer整体框架" class="headerlink" title="一、transformer整体框架"></a>一、transformer整体框架</h1><ul><li><p>该架构主要分为两大块，Encoders和Decoders</p></li><li><p>这两块分别由6个Encoders和Decoders组成。</p></li><li><p><strong>Encoders</strong>的功能就是抽取特征的，抽取出来的特征就交给<strong>Decoders</strong>，<strong>Decoders</strong>用<strong>Encoders</strong>抽取到的特征去做具体的任务</p></li><li><p>以往网络架构有所区别的是，<strong>该网络架构中，编码器和解码器没有采用 RNN 或 CNN 等网络架构，而是采用完全依赖于注意力机制的架构</strong></p></li></ul><p><strong>注：为什么不用RNN，而使用注意力机制</strong></p><ul><li>考虑到RNN的计算限制为顺序的，RNN的相关算法只能从左往右依次计算或者从右往左依次计算，这种机制带来了两个问题。</li><li>第一个问题：时间t时刻的计算要依赖前一个时刻的输出信息，这样限制了模型的并行能力</li><li>第二个问题：顺序计算的过程中信息会丢失。尽管LSTM一定程度缓解了RNN的长期依赖的问题，但是对于特别长期的依赖现象，还是无能为力。</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210091947688.png" alt="image-20221009194701166"></p><h1 id="二、Transformer直观认识"><a href="#二、Transformer直观认识" class="headerlink" title="二、Transformer直观认识"></a>二、Transformer直观认识</h1><p><strong>transformer结构：</strong></p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210091923676.png" alt="image-20221009192352691"></p><p><strong>注：</strong>这6个部分各自都在训练</p><p><strong>其中每个encoder和decoder的内部结构如下：</strong></p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210091925574.png" alt="image-20221009192508128"></p><p>对于encoder，有两层 :</p><ul><li>自注意力层  帮助获取上下文语义信息</li><li>一个前馈神经网络</li></ul><p><strong>对于decoder层：</strong></p><ul><li>decoder中间有一层attention层，帮助当前节点获取到当前需要关注的重点内容。</li></ul><p><strong>流程：</strong></p><ul><li>首先，模型需要对输入的数据进行一个embedding操作，enmbedding结束之后，输入到encoder层，self-attention处理完数据后把数据送给前馈神经网络，前馈神经网络的计算可以并行，得到的输出会输入到下一个encoder。</li></ul><h1 id="三、Encoder与Decoder"><a href="#三、Encoder与Decoder" class="headerlink" title="三、Encoder与Decoder"></a>三、Encoder与Decoder</h1><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210092012104.png" alt="image-20221009201226717"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList详解</title>
      <link href="/2022/10/06/Java/ArrayList%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/10/06/Java/ArrayList%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayLIst详解"><a href="#ArrayLIst详解" class="headerlink" title="ArrayLIst详解"></a>ArrayLIst详解</h1><h1 id="一、ArrayList基础使用"><a href="#一、ArrayList基础使用" class="headerlink" title="一、ArrayList基础使用"></a>一、ArrayList基础使用</h1><h2 id="1-ArrayList类使用"><a href="#1-ArrayList类使用" class="headerlink" title="1.ArrayList类使用"></a>1.ArrayList类使用</h2><p>​        作用：提供一个可用长度的集合，底层实际上是一个可变长度的数组<br>​        格式：ArrayList<E> arr &#x3D; new ArrayList&lt;&gt;(); 构造方法</p><h2 id="2-ArrayList的构造和添加方法"><a href="#2-ArrayList的构造和添加方法" class="headerlink" title="2.ArrayList的构造和添加方法"></a>2.ArrayList的构造和添加方法</h2><p>​    1）public ArrayList() 创建一个空的集合对象<br>​    2）public boolean add(E e)  将指定的元素插入到集合尾部<br>​    3）public void add(int index,E element) 在此集合的指定索引处插入指定的元素</p><h2 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3.常用方法"></a>3.常用方法</h2><p>​        1）public boolean remove(Object o)<br>​        删除指定元素  并且返回true或者false<br>​        2)public E remove(int index)<br>​        删除索引处的元素  并且返回删除的元素的值<br>​        3)public E set(int index,E element)<br>​        修改索引处的值  并返回修改之前的元素<br>​        4）public E get(int index)<br>​        返回索引处的值<br>​        5）public int size()<br>​        返回集合元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(getArrayList());<br>        System.out.println(getNewArrayLIst(getArrayList()));<br>    &#125;<br>  <span class="hljs-comment">//这里完成ArrayList的初始化和赋值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList <span class="hljs-title function_">getArrayList</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ArrayList</span> <span class="hljs-variable">arrayList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<span class="hljs-comment">//构造函数 初始化一个ArrayList</span><br>        arrayList.add(<span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">//添加 张三</span><br>        arrayList.add(<span class="hljs-string">&quot;李四&quot;</span>); <span class="hljs-comment">//添加 李四</span><br>        arrayList.add(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;王五&quot;</span>);<span class="hljs-comment">//添加 王五  位置1</span><br>        <span class="hljs-keyword">return</span> arrayList;<br>    &#125;<br> <span class="hljs-comment">//这里对方法进行练习 删除修改等</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList <span class="hljs-title function_">getNewArrayLIst</span><span class="hljs-params">(ArrayList al)</span>&#123;<br><span class="hljs-comment">//        al.remove(&quot;王五&quot;);//删除王五元素  输出[张三, 李四]</span><br><span class="hljs-comment">//        al.remove(0);//删除索引位置0的元素 输出[王五, 李四]</span><br>        al.set(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;王三&quot;</span>);<span class="hljs-comment">//修改第一个值为王三</span><br>        <span class="hljs-keyword">return</span> al;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-循环访问"><a href="#4-循环访问" class="headerlink" title="4.循环访问"></a>4.循环访问</h2><ul><li>for循环访问</li><li>这一种最常见，也最容易想到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">CurrentRead1</span><span class="hljs-params">(ArrayList al)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i&lt;al.size(); i++) &#123;<br>            System.out.println(al.get(i));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>使用迭代器访问</li><li>这一种使用迭代器 很不错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一步，创建集合al的迭代器</span><br><span class="hljs-comment">//第二步，使用while进行遍历  使用hasNext() 和next()进行配合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">CurrentRead</span><span class="hljs-params">(ArrayList al)</span>&#123;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span>al.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext())&#123;<br>            System.out.println(it.next());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>for each进行循环</li><li>这个类似python中 for i in list  列表的循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">CurrentRead2</span><span class="hljs-params">(ArrayList al)</span>&#123;<br>        <span class="hljs-keyword">for</span>(Object k : al)&#123;<br>            System.out.println(k);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>使用ArrayList,需要导入包</li><li>获取元素时需要使用<code>get(index)</code>，不能像python列表那样使用<code>arraylist[index]</code>获取元素</li><li>获取最后一个元素不能用<code>get(-1)</code>，就用<code>get(arraylist.size() -1)</code></li><li>获取长度用<code>arraylist.size()</code>，不是<code>arraylist.length</code></li></ul><h1 id="二、ArrayList-与-数组的转换"><a href="#二、ArrayList-与-数组的转换" class="headerlink" title="二、ArrayList 与 数组的转换"></a>二、ArrayList 与 数组的转换</h1><h2 id="1-ArrayList转化为数组"><a href="#1-ArrayList转化为数组" class="headerlink" title="1.ArrayList转化为数组"></a>1.ArrayList转化为数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listToArray</span><span class="hljs-params">(ArrayList&lt;String&gt; list)</span>&#123;<br>        <span class="hljs-comment">//使用toArray()</span><br>        String[] arrays =  list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[list.size()]);<br>        <span class="hljs-keyword">for</span> (String array:arrays) &#123;<br>            System.out.print(array+<span class="hljs-string">&quot; &quot;</span>);  <span class="hljs-comment">//a b c</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-数组转化为ArrayList"><a href="#2-数组转化为ArrayList" class="headerlink" title="2.数组转化为ArrayList"></a>2.数组转化为ArrayList</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static  <span class="hljs-type">void</span> array2list()&#123;<br>        <span class="hljs-type">Integer</span>[] <span class="hljs-keyword">array</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Integer</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">array</span>[i]=i;<br>        &#125;<br>        List&lt;<span class="hljs-type">Integer</span>&gt; lists = Arrays.asList(<span class="hljs-keyword">array</span>);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(lists);<br>    &#125;<br>//[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h1 id="三、ArrayList的内部实现"><a href="#三、ArrayList的内部实现" class="headerlink" title="三、ArrayList的内部实现"></a>三、ArrayList的内部实现</h1><p><strong>注：通过阅读ArrayList的源码发现其内部的实现原理</strong></p><h2 id="1-接口"><a href="#1-接口" class="headerlink" title="1.接口"></a>1.接口</h2><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210062038788.png" alt="image-20221006203756861"></p><ul><li>阅读源码发现ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</li></ul><h2 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h2><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210062045617.png" alt="image-20221006204505290"></p><ul><li>elementData 用来存储ArrayList元素</li><li>size 用来表示大小</li></ul><h2 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3.构造方法"></a>3.构造方法</h2><ul><li>阅读源码，发现使用了三种构造方法</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210062104601.png" alt="image-20221006210436278"></p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210062103241.png" alt="image-20221006210350908"></p><p>1）对于第一种构造方法 ：</p><ul><li>有一个参数initialCapacity 代表初始化的大小</li><li>逻辑为若该参数&gt;0,则创建；&#x3D;0，则赋值为空；否则&lt;0，则抛出异常</li></ul><p>2）第二种构造方法：</p><ul><li>无参数</li><li>创建默认的大小  默认为10</li></ul><p>3）第三种构造方法</p><ul><li>如果参数数组里有值，如果类型又是ArrayList型，就赋值给存储，否则要使用copyof函数进行新旧数组的转换再赋值。如果数组里没有值，直接为空。</li></ul><h2 id="4-实现方法"><a href="#4-实现方法" class="headerlink" title="4.实现方法"></a>4.实现方法</h2><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210062155083.png" alt="image-20221006212315994"></p><p>1）size()方法，返回size数值</p><p>2）isEmpty()方法，判断size是否等于0</p><p>3）contains()方法，使用indexof(0) &gt;&#x3D;0 返回布尔值 如果大于等于0,说明能找到，否则返回的是-1.没有这个元素</p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210062127299.png" alt="image-20221006212742003"></p><p>4）indexof(o)方法</p><ul><li>如果o为null,就遍历，能找到一个为null的值的话，就返回索引。</li><li>如果o不为null，就遍历，遇到相等，就返回索引</li><li>前两者都不是，就会返回-1</li></ul><p><strong>注：这里有个疑问：为什莫要区分是不是null的情况</strong></p><p><strong>equals &#x3D;&#x3D;</strong></p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210062135995.png" alt="image-20221006213533836"></p><p>5）get()方法</p><ul><li>有一个参数 索引index</li><li>先检查索引是否越界  再返回索引的值</li></ul><p>6)set()方法</p><ul><li>index element两个参数</li><li>先检查是否越界 </li><li>然后oldvalue保存旧元素</li><li>再赋值新元素</li><li>返回旧元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map详解</title>
      <link href="/2022/10/05/GO/map%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/10/05/GO/map%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="map详解"><a href="#map详解" class="headerlink" title="map详解"></a>map详解</h1><h1 id="一、map简介"><a href="#一、map简介" class="headerlink" title="一、map简介"></a>一、map简介</h1><h2 id="1-基础介绍"><a href="#1-基础介绍" class="headerlink" title="1.基础介绍"></a>1.基础介绍</h2><ul><li>map是无序的基于key-value的数据结构</li><li>Go语言中的map是引用类型，必须初始化才能使用</li></ul><p>go中map定义语法如下</p><ul><li>map[keyType]ValueType<ul><li>就是括号里定义的是键的类型，括号外后面定义值的类型</li></ul></li><li>map类型的变量默认初始值为nil,需要使用make()函数来分配内存<ul><li>make()：用于slice、map、channel的初始化</li></ul></li></ul><p><strong>注：</strong>初始感觉类似与python中的字典</p><h2 id="2-map的声明、初始化"><a href="#2-map的声明、初始化" class="headerlink" title="2.map的声明、初始化"></a>2.map的声明、初始化</h2><ul><li>第一种方式</li><li>在创建之后 再进行初始化</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>m[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">1</span><br>m[<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-number">2</span><br>m[<span class="hljs-string">&quot;c&quot;</span>] = <span class="hljs-number">3</span><br>fmt.Println(m)<br>fmt.Println(m[<span class="hljs-string">&quot;a&quot;</span>])<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注：</strong>在使用m[“a”]取值时，使用单引号会报错  字符串使用双引号</p><ul><li>第二种方式</li><li>在创建时同时进行初始化</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-number">3</span>,<br>&#125;<br><br>fmt.Println(m)<br>fmt.Println(m[<span class="hljs-string">&quot;a&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注：</strong> </p><ul><li>使用第二种方式时，不必要在使用make()函数</li><li>使用该方式赋值时，每一行都要逗号结尾</li></ul><h2 id="3-map的遍历"><a href="#3-map的遍历" class="headerlink" title="3.map的遍历"></a>3.map的遍历</h2><ul><li>使用for-range循环进行遍历</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-number">3</span>,<br>&#125;<br>fmt.Println(m)<br>fmt.Println(<span class="hljs-string">&quot;-------------&quot;</span>)<br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> m &#123;<br>fmt.Println(<span class="hljs-string">&quot;key=&quot;</span>, key, <span class="hljs-string">&quot;value=&quot;</span>, value)<br>&#125;<br>&#125;<br><span class="hljs-comment">//map[a:1 b:2 c:3]</span><br><span class="hljs-comment">//-------------</span><br><span class="hljs-comment">//key= a value= 1</span><br><span class="hljs-comment">//key= b value= 2</span><br><span class="hljs-comment">//key= c value= 3</span><br></code></pre></td></tr></table></figure><h2 id="4-判断map中某值存在"><a href="#4-判断map中某值存在" class="headerlink" title="4.判断map中某值存在"></a>4.判断map中某值存在</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-number">3</span>,<br>&#125;<br>value, value1 := m[<span class="hljs-string">&quot;a&quot;</span>]<br>fmt.Println(m[<span class="hljs-string">&quot;a&quot;</span>])<br>fmt.Println(value, value1)<br>&#125;<br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//1 true</span><br></code></pre></td></tr></table></figure><p><strong>注：</strong>判断是否存在时很简单  在获取m[“a”]时，会有两个返回值。如果一个变量，则是里面的值；如果两个变量去赋值，则定一返回true or false。表示是否存在</p><h2 id="5-使用delete-函数删除键值对"><a href="#5-使用delete-函数删除键值对" class="headerlink" title="5.使用delete()函数删除键值对"></a>5.使用delete()函数删除键值对</h2><ul><li>delete(map对象,key)<ul><li>map对象：要删除键值对的map对象</li><li>key：要删除键值对的键</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;b&quot;</span>)<br>fmt.Println(m[<span class="hljs-string">&quot;b&quot;</span>])<br></code></pre></td></tr></table></figure><h2 id="6-元素为map类型的切片"><a href="#6-元素为map类型的切片" class="headerlink" title="6.元素为map类型的切片"></a>6.元素为map类型的切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> userInfoList = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">var</span> user = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;userName&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br><span class="hljs-string">&quot;age&quot;</span>:      <span class="hljs-string">&quot;1&quot;</span>,<br>&#125;<br><span class="hljs-keyword">var</span> user2 = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;userName&quot;</span>: <span class="hljs-string">&quot;李四&quot;</span>,<br><span class="hljs-string">&quot;age&quot;</span>:      <span class="hljs-string">&quot;2&quot;</span>,<br>&#125;<br><span class="hljs-keyword">var</span> user3 = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;userName&quot;</span>: <span class="hljs-string">&quot;王五&quot;</span>,<br><span class="hljs-string">&quot;age&quot;</span>:      <span class="hljs-string">&quot;3&quot;</span>,<br>&#125;<br>userInfoList[<span class="hljs-number">0</span>] = user<br>userInfoList[<span class="hljs-number">1</span>] = user2<br>userInfoList[<span class="hljs-number">2</span>] = user3<br>fmt.Println(userInfoList)<br><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> userInfoList &#123;<br>fmt.Println(item)<br>&#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">//[map[age:1 userName:张三] map[age:2 userName:李四] map[age:3 userName:王五]]</span><br><span class="hljs-comment">//map[age:1 userName:张三]</span><br><span class="hljs-comment">//map[age:2 userName:李四]</span><br><span class="hljs-comment">//map[age:3 userName:王五]</span><br></code></pre></td></tr></table></figure><h2 id="7-值为切片类型的map"><a href="#7-值为切片类型的map" class="headerlink" title="7.值为切片类型的map"></a>7.值为切片类型的map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> userinfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>)<br>userinfo[<span class="hljs-string">&quot;hobby&quot;</span>] = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;吃饭1&quot;</span>, <span class="hljs-string">&quot;吃饭2&quot;</span>, <span class="hljs-string">&quot;吃饭3&quot;</span>&#125;<br>fmt.Println(userinfo[<span class="hljs-string">&quot;hobby&quot;</span>][<span class="hljs-number">0</span>])<br>&#125;<br><span class="hljs-comment">//吃饭1</span><br></code></pre></td></tr></table></figure><p><strong>注：</strong>以上两种方法初始感觉像python中字典和列表的嵌套</p><h1 id="二、map进阶"><a href="#二、map进阶" class="headerlink" title="二、map进阶"></a>二、map进阶</h1><h2 id="1-map存原理"><a href="#1-map存原理" class="headerlink" title="1.map存原理"></a>1.map存原理</h2><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210052149127.png" alt="image-20221005214902584"></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题记录</title>
      <link href="/2022/10/05/Leetcode/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/10/05/Leetcode/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GO循环语法基础</title>
      <link href="/2022/10/05/GO/GO%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/10/05/GO/GO%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Go循环语法"><a href="#Go循环语法" class="headerlink" title="Go循环语法"></a>Go循环语法</h1><p><strong>Go语言只允许for循环格式，没有while和do…while结构</strong></p><h2 id="1-第一种方式"><a href="#1-第一种方式" class="headerlink" title="1.第一种方式"></a>1.第一种方式</h2><ul><li><p>跟c语言类似 需要声明</p></li><li><p>for 循环的表达式 不需要()</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;i=&quot;</span>, i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-第二种方式"><a href="#2-第二种方式" class="headerlink" title="2.第二种方式"></a>2.第二种方式</h2><ul><li>类似于while的感觉  使用判断，执行操作语句，变量自增</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">10</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;i=&quot;</span>, i)<br>i++<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-第三种方式"><a href="#3-第三种方式" class="headerlink" title="3.第三种方式"></a>3.第三种方式</h2><ul><li>无线循环，结合break来使用</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">//无限循环  如果小于10，打印；否则break</span><br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;i=&quot;</span>, i)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>i++<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-第四种方式"><a href="#4-第四种方式" class="headerlink" title="4.第四种方式"></a>4.第四种方式</h2><ul><li><p>使用for-range方式，用来遍历字符串和数组</p><ul><li>类似于python 循环列表的方式</li></ul></li><li><p>以下示例，第一个是传统方式,第二种 使用for-range</p><ul><li>发现for-range这种方式，会有两个index(索引),value(值)的方式。类似于python字典遍历</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-comment">// for i := 0; i &lt; len(str); i++ &#123;</span><br><span class="hljs-comment">// fmt.Printf(&quot;%c\n&quot;, str[i])</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> str &#123;<br>fmt.Printf(<span class="hljs-string">&quot;index=%d, value=%c  \n&quot;</span>, index, value)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO入门</title>
      <link href="/2022/10/04/GO/Go%E5%85%A5%E9%97%A8/"/>
      <url>/2022/10/04/GO/Go%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-顺序编程"><a href="#第二章-顺序编程" class="headerlink" title="第二章 顺序编程"></a>第二章 顺序编程</h1><h1 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h1><h2 id="1-变量声明"><a href="#1-变量声明" class="headerlink" title="1.变量声明"></a>1.变量声明</h2><ul><li>变量声明语句  不需要分号作为结束符  跟python类似</li><li>使用var 进行声明  并后续加入类型</li><li>另一种方式 定义  可以使用 var()定义多个</li><li>var (<br>    v9 int &#x3D; 9<br>    v10 int &#x3D;10<br>)</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> v1 <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> v2 <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> v3 [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> v4 []<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> v5 <span class="hljs-keyword">struct</span> &#123;<br>f <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">var</span> v6 *<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> v7 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> v8 <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><h2 id="2-变量初始化"><a href="#2-变量初始化" class="headerlink" title="2.变量初始化"></a>2.变量初始化</h2><p><strong>以下三种赋值方式均可：</strong></p><ul><li><p>完整使用方式</p></li><li><p>省略类型  编译器会自动推导类型</p></li><li><p>最简洁 输入字符数最少  使用:&#x3D;用于明确表明同时进行变量声明和初始化工作</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>  <span class="hljs-keyword">var</span> s1 <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><br>  <span class="hljs-keyword">var</span> s2 = <span class="hljs-number">1</span><br><br>  s3 := <span class="hljs-number">1</span><br><br>  fmt.Println(s1, s2, s3)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上是没有问题的。但是如果没有使用函数内赋值，直接写在外面，就会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1 <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> s2 = <span class="hljs-number">1</span><br><span class="hljs-comment">// s3 := 1</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// var s1 int = 1</span><br><span class="hljs-comment">// var s2 = 1</span><br><span class="hljs-comment">// s3 := 1</span><br>fmt.Println(s1, s2)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样也是没报错的。但是如果使用第三种赋值 s3:&#x3D;1，就会报错。</p><p>提示：syntax error: non-declaration statement outside function body</p><p><strong>注意：</strong>在func外,每个语句都必须是golang的关键字开始,否则就报这个错，写在函数体内就好。</p><p>所以就会发现使用了 var关键字声明的在函数体外没有报错，但是第三种使用:&#x3D;就报错了。</p><h2 id="3-变量赋值"><a href="#3-变量赋值" class="headerlink" title="3.变量赋值"></a>3.变量赋值</h2><p>在go语言中，变量初始化和变量赋值是两个不同的概念。</p><p>这里主要注意一个多重赋值功能：</p><ul><li><code>i,j = j,1</code>  </li><li>不用再引入中间变量作为存储，更加方便</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v1 := <span class="hljs-number">1</span><br>v2 := <span class="hljs-number">2</span><br>fmt.Println(v1, v2) <span class="hljs-comment">//1,2</span><br>v1, v2 = v2, v1<br>fmt.Println(v1, v2) <span class="hljs-comment">//2,1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-匿名变量"><a href="#4-匿名变量" class="headerlink" title="4.匿名变量"></a>4.匿名变量</h2><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202210042131529.png" alt="image-20221004170451932"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>_, _, nickname := GetName()<br>fmt.Println(nickname)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span></span> (firstName, lastName, nickName <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;456&quot;</span>, <span class="hljs-string">&quot;789&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出为 789</strong></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scrapy框架五大组件</title>
      <link href="/2022/09/24/Python/scrapy%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/09/24/Python/scrapy%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="五大核心组件"><a href="#五大核心组件" class="headerlink" title="五大核心组件"></a>五大核心组件</h1>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scapy框架使用流程</title>
      <link href="/2022/09/23/Python/scrapy%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/09/23/Python/scrapy%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Scrapy框架入门"><a href="#Scrapy框架入门" class="headerlink" title="Scrapy框架入门"></a>Scrapy框架入门</h1><h1 id="一、scrapy框架初识"><a href="#一、scrapy框架初识" class="headerlink" title="一、scrapy框架初识"></a>一、scrapy框架初识</h1><p><strong>1.什么是框架</strong></p><ul><li>一个集成了很多功能并且具有很多通用性的一个项目模板</li></ul><p><strong>2.如何学习框架</strong></p><ul><li>首先学习框架的各个功能的详细用法</li><li>后面可以再读源码</li></ul><p><strong>3.什么是scrapy框架</strong></p><ul><li>爬虫中封装好的一个明星框架</li><li>封装多种功能<ul><li>高性能的持久化存储</li><li>异步的数据下载</li><li>高性能的数据解析</li><li>分布式</li></ul></li></ul><h1 id="二、scrapy环境安装"><a href="#二、scrapy环境安装" class="headerlink" title="二、scrapy环境安装"></a>二、scrapy环境安装</h1><p><strong>windows安装</strong></p><ul><li>pip install  wheel </li><li>下载 twisted 为了实现scrpy中的异步下载<ul><li><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a></li></ul></li><li>安装twisted  pip install  xxx.whl</li><li>pip install pywin32</li><li>pip install scrapy</li></ul><p>安装好，终端输入scrapy报错。<code>AttributeError: module &#39;OpenSSL.SSL&#39; has no attribute &#39;TLS_METHOD&#39;</code></p><p>解决办法：uninstall pyopenssl即可。然后重新install</p><h1 id="三、scrapy基本使用"><a href="#三、scrapy基本使用" class="headerlink" title="三、scrapy基本使用"></a>三、scrapy基本使用</h1><p>1.创建一个工程： scrapy  startproject  name</p><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202209231505661.png" alt="image-20220923150550351"></p><p>spiders子目录下放一个爬虫文件</p><p>settings.py是当前工程对应的配置文件</p><p>2.在spiders子目录下创建一个爬虫文件</p><ul><li><p>scrapy genspider first <a href="http://www.baidu.com/">www.baidu.com</a></p><ul><li>在工程文件夹下使用本条命令</li></ul></li></ul><p>3.执行工程</p><ul><li>scrapy crawl spiderName(即 first)</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202209231504302.png" alt="image-20220923150442800"></p><ul><li><p>name是爬虫的文件名称:爬虫源文件唯一标识</p></li><li><p>allowed_domains是允许的域名，用来限定 start_urls列表中那些URL可以进行请求和发送</p></li><li><p>start_urls是起始的url ，列表中存放的URL会被Scrapy自动进行请求发送</p></li><li><p>parse(self,response)函数： 用作于解析数据：response参数表示请求成功后对应的响应对象</p></li></ul><p>注：当程序运行时，会直接对列表的url进行访问，同时调用parse()获取返回值。如果url列表里有两个url，则调用了两次parse()函数</p><h1 id="四、scrapy数据解析"><a href="#四、scrapy数据解析" class="headerlink" title="四、scrapy数据解析"></a>四、scrapy数据解析</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>    <span class="hljs-comment"># 获取： 获取坦克名+url+创建时间</span><br>    list_dls = response.xpath(<span class="hljs-string">&#x27;//dl[@class=&quot;col-dl&quot;]&#x27;</span>)<br>    <span class="hljs-comment"># print(list_dls.extract()[0])</span><br>    <span class="hljs-keyword">for</span> list_dl <span class="hljs-keyword">in</span> list_dls:<br>        <span class="hljs-comment"># xpath返回的是一个列表，但是列表元素一定是Selector类型的对象</span><br>        <span class="hljs-comment"># extract可以将Selector对象中data参数存储的字符串提取出来</span><br>        title = list_dl.xpath(<span class="hljs-string">&quot;./dt/a/text()&quot;</span>).extract()  <span class="hljs-comment"># 标题</span><br>        title = <span class="hljs-string">&#x27;&#x27;</span>.join(title)  <span class="hljs-comment"># .join()列表转为字符串</span><br>        url = <span class="hljs-string">&quot;http://www.wuqibaike.com&quot;</span> + list_dl.xpath(<span class="hljs-string">&quot;./dt/a/@href&quot;</span>).extract()[<span class="hljs-number">0</span>]  <span class="hljs-comment">#url</span><br>        <span class="hljs-built_in">print</span>(title, url)<br></code></pre></td></tr></table></figure><p><strong>总结几点：</strong></p><ul><li>在parse()函数里实现数据解析  可以直接调用response参数，支持xpath提取操作</li><li>对于xpath的学习</li><li>‘’.join()函数 实现列表转化为字符串</li></ul><h1 id="五、持久化存储"><a href="#五、持久化存储" class="headerlink" title="五、持久化存储"></a>五、持久化存储</h1><h2 id="1-基于终端指令的持久化存储"><a href="#1-基于终端指令的持久化存储" class="headerlink" title="1.基于终端指令的持久化存储"></a>1.基于终端指令的持久化存储</h2><p><strong>要求</strong>：只可以将parse()方法的返回值存储到本地的文本文件中</p><p><strong>指令：</strong>scrapy crawl xxx -o  filename.类型</p><p><strong>好处：</strong>快捷简单高效</p><p><strong>缺点：</strong>局限性比较强</p><p>基于终端指令，我们要将parse()函数写一个返回值  通过列表嵌套字典的方式进行封装，最后返回列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>    <span class="hljs-comment"># 获取： 获取坦克名+url+创建时间</span><br>    list_dls = response.xpath(<span class="hljs-string">&#x27;//dl[@class=&quot;col-dl&quot;]&#x27;</span>)<br>    <span class="hljs-comment"># print(list_dls.extract()[0])</span><br>    list_data = []<br>    <span class="hljs-keyword">for</span> list_dl <span class="hljs-keyword">in</span> list_dls:<br>        <span class="hljs-comment"># xpath返回的是一个列表，但是列表元素一定是Selector类型的对象</span><br>        <span class="hljs-comment"># extract可以将Selector对象中data参数存储的字符串提取出来</span><br>        title = list_dl.xpath(<span class="hljs-string">&quot;./dt/a/text()&quot;</span>).extract()  <span class="hljs-comment"># 标题</span><br>        title = <span class="hljs-string">&#x27;&#x27;</span>.join(title)  <span class="hljs-comment"># .join()列表转为字符串</span><br>        url = <span class="hljs-string">&quot;http://www.wuqibaike.com&quot;</span> + list_dl.xpath(<span class="hljs-string">&quot;./dt/a/@href&quot;</span>).extract()[<span class="hljs-number">0</span>]  <span class="hljs-comment"># url</span><br>        <span class="hljs-comment"># print(title, url)</span><br>        dic = &#123;<br>            <span class="hljs-string">&#x27;title&#x27;</span>: title,<br>            <span class="hljs-string">&#x27;url&#x27;</span>: url<br>        &#125;<br>        list_data.append(dic)<br>    <span class="hljs-keyword">return</span> list_data<br></code></pre></td></tr></table></figure><h2 id="2-基于管道的持久化存储操作"><a href="#2-基于管道的持久化存储操作" class="headerlink" title="2.基于管道的持久化存储操作"></a>2.基于管道的持久化存储操作</h2><p><strong>更加常用，优点更多</strong></p><p><strong>编码流程：</strong></p><ul><li>数据解析</li><li>在实例化之前，在item类中定义相关的属性<ul><li><code>title = scrapy.Field()</code></li></ul></li><li>实例化对象，将解析的数据封装存储到item类型的对象中</li><li>将item类型的对象提交给管道进行持久化存储的操作</li><li>在管道类的process_item中要将其接受到的item对象中存储的数据进行持久化的操作</li><li>在配置文件中开启管道</li></ul><p>好处：通用性强</p><p>坏处：编码繁琐一些</p><p><strong>面试题：</strong>将爬取到的数据一份存储到本地，一份存储到数据库，该怎莫实现？</p><p><strong>具体步骤：</strong></p><p>第一步：数据解析</p><p>第二步：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QiubaiproItem</span>(scrapy.Item):<br>    <span class="hljs-comment"># define the fields for your item here like:</span><br>    <span class="hljs-comment"># name = scrapy.Field()</span><br>    title = scrapy.Field()<br>    url = scrapy.Field()<br></code></pre></td></tr></table></figure><p>第三步：提交给管道</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">item = QiubaiproItem()<br>item[<span class="hljs-string">&#x27;title&#x27;</span>] = title<br>item[<span class="hljs-string">&#x27;url&#x27;</span>] = url<br><br><span class="hljs-keyword">yield</span> item  <span class="hljs-comment"># 将item提交给管道   每循环一次  就会提交一次item给管道</span><br></code></pre></td></tr></table></figure><p>第四步：持久化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QiubaiproPipeline</span>:<br>    fp = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 重写父类方法  该方法只会被开始爬虫调用一次</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open_spider</span>(<span class="hljs-params">self, spider</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始爬虫......&quot;</span>)<br>        self.fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./qiubai.txt&quot;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-comment"># 专门处理item类型对象</span><br>    <span class="hljs-comment"># 该方法可以接受爬虫文件提交过来的item对象</span><br>    <span class="hljs-comment"># 该方法每接受到一个item就会被调用一次</span><br>    <span class="hljs-comment"># 不能直接在里面写入文件  会造成多次打开文件</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        title = item[<span class="hljs-string">&#x27;title&#x27;</span>]<br>        url = item[<span class="hljs-string">&#x27;url&#x27;</span>]<br>        self.fp.write(title + <span class="hljs-string">&quot;:&quot;</span> + url + <span class="hljs-string">&quot;\n&quot;</span>)<br>        <span class="hljs-keyword">return</span> item<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_spider</span>(<span class="hljs-params">self, spider</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬虫结束&quot;</span>)<br>        self.fp.close()<br></code></pre></td></tr></table></figure><p>最后：</p><p>修改配置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ITEM_PIPELINES = &#123;<br>    <span class="hljs-string">&#x27;qiubaipro.pipelines.QiubaiproPipeline&#x27;</span>: <span class="hljs-number">300</span>,<br>    <span class="hljs-comment"># 300表示的优先级，数值越小优先级越高</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> scrapy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python列表转为字典</title>
      <link href="/2022/09/18/Python/python%E5%88%97%E8%A1%A8%E8%BD%AC%E4%B8%BA%E5%AD%97%E5%85%B8/"/>
      <url>/2022/09/18/Python/python%E5%88%97%E8%A1%A8%E8%BD%AC%E4%B8%BA%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="将列表转化为字典"><a href="#将列表转化为字典" class="headerlink" title="将列表转化为字典"></a>将列表转化为字典</h1><p>一、两个列表对应转化为键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-string">&#x27;four&#x27;</span>, <span class="hljs-string">&#x27;five&#x27;</span>]<br>list2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>dict1 = <span class="hljs-built_in">zip</span>(list1, list2)<br>dict2 = <span class="hljs-built_in">dict</span>(dict1)<br><span class="hljs-built_in">print</span>(dict2)<br><span class="hljs-comment">#&#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3, &#x27;four&#x27;: 4, &#x27;five&#x27;: 5&#125;</span><br></code></pre></td></tr></table></figure><p>注：<strong>该方法会自动对齐两个列表。比如其中一个列表长度为5，另一个列表长度为6，经测试发现，只会以长度小的为准，组成新的字典。</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 字典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python字典</title>
      <link href="/2022/09/17/Python/python%E5%AD%97%E5%85%B8/"/>
      <url>/2022/09/17/Python/python%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="Python字典"><a href="#Python字典" class="headerlink" title="Python字典"></a>Python字典</h1><ul><li>可以使用字典这种数据结构来存储数据。</li></ul><h1 id="一、创建字典"><a href="#一、创建字典" class="headerlink" title="一、创建字典"></a>一、创建字典</h1><h2 id="1-字典格式："><a href="#1-字典格式：" class="headerlink" title="1.字典格式："></a>1.字典格式：</h2><p><code>dict = &#123;key1: value1, key2: value2, key3: value3&#125;</code></p><h2 id="2-创建字典："><a href="#2-创建字典：" class="headerlink" title="2.创建字典："></a>2.创建字典：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建空字典，有两种方式</span><br><span class="hljs-comment"># 第一种</span><br>dict1 = <span class="hljs-built_in">dict</span>()<br>dict2 = &#123;&#125;<br><br><span class="hljs-comment"># 创建非空字典</span><br>dict3 = &#123;<span class="hljs-string">&quot;name&quot;</span>: [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>], <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">12</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>字典中的键是唯一的，字典中的值是任意数据类型。如上面代码所示，值可以嵌套列表，也可以是数值等</li></ul><h1 id="二、访问字典"><a href="#二、访问字典" class="headerlink" title="二、访问字典"></a>二、访问字典</h1><ul><li>键和值也就是key和value，一一对用。通过键来获取其中的值</li></ul><h2 id="1-方法一：dict-key"><a href="#1-方法一：dict-key" class="headerlink" title="1.方法一：dict[key]"></a>1.方法一：dict[key]</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">dict3 = &#123;<span class="hljs-string">&quot;name&quot;</span>: [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>], <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">12</span>&#125;<br><span class="hljs-built_in">print</span>(dict3[<span class="hljs-string">&quot;name&quot;</span>])<br><span class="hljs-built_in">print</span>(dict3[<span class="hljs-string">&quot;name&quot;</span>][<span class="hljs-number">0</span>])<br><span class="hljs-comment">#输出</span><br><span class="hljs-comment">#[&#x27;hello&#x27;, &#x27;world&#x27;]</span><br><span class="hljs-comment">#hello</span><br></code></pre></td></tr></table></figure><h2 id="2-方法二：使用dict-get-key"><a href="#2-方法二：使用dict-get-key" class="headerlink" title="2.方法二：使用dict.get(key)"></a>2.方法二：使用dict.get(key)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------------------------------&quot;</span>)<br><span class="hljs-built_in">print</span>(dict3.get(<span class="hljs-string">&quot;name&quot;</span>))<br><span class="hljs-built_in">print</span>(dict3.get(<span class="hljs-string">&quot;age&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="3-两种方法区别"><a href="#3-两种方法区别" class="headerlink" title="3.两种方法区别"></a>3.两种方法区别</h2><ul><li><p>首先，当获取的值不存在时，方法一会直接报错<code>KeyError: &#39;name1&#39;</code>，而方法二会返回None,并不会报错<code>None</code>。</p></li><li><p>使用get()的方法可以让其返回一个指定的值。当然这个操作并不会改变原本字典的内容</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------------------------------&quot;</span>)<br><span class="hljs-built_in">print</span>(dict3.get(<span class="hljs-string">&quot;name&quot;</span>))<br><span class="hljs-built_in">print</span>(dict3.get(<span class="hljs-string">&quot;age1&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>))<br><span class="hljs-comment">#输出</span><br><span class="hljs-comment">#[&#x27;hello&#x27;, &#x27;world&#x27;]</span><br><span class="hljs-comment">#111</span><br></code></pre></td></tr></table></figure><p>注：因为字典中的键不存在age1，所以返回值为111</p><h1 id="三、更新字典"><a href="#三、更新字典" class="headerlink" title="三、更新字典"></a>三、更新字典</h1><h2 id="1-方法一：dict-key-1"><a href="#1-方法一：dict-key-1" class="headerlink" title="1.方法一：dict[key]"></a>1.方法一：dict[key]</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------------------------------&quot;</span>)<br><span class="hljs-built_in">print</span>(dict3.get(<span class="hljs-string">&quot;name&quot;</span>))<span class="hljs-comment">#[&#x27;hello&#x27;, &#x27;world&#x27;]</span><br>dict3[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-built_in">print</span>(dict3.get(<span class="hljs-string">&quot;name&quot;</span>))<span class="hljs-comment">#123</span><br></code></pre></td></tr></table></figure><p>直接对键取值进行赋值即可。</p><h2 id="2-方法二：-update-dict"><a href="#2-方法二：-update-dict" class="headerlink" title="2.方法二： update(dict)"></a>2.方法二： update(dict)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------------------------------&quot;</span>)<br><span class="hljs-built_in">print</span>(dict3)<br><span class="hljs-built_in">print</span>(dict2)<br>dict3.update(dict2)<br><span class="hljs-built_in">print</span>(dict3)<br><span class="hljs-comment">#----------------------------------</span><br><span class="hljs-comment">#&#123;&#x27;name&#x27;: &#x27;123&#x27;, &#x27;age&#x27;: 12&#125;</span><br><span class="hljs-comment">#&#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;age&#x27;: 12&#125;</span><br><span class="hljs-comment">#&#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;age&#x27;: 12&#125;</span><br></code></pre></td></tr></table></figure><h1 id="四、删除字典元素"><a href="#四、删除字典元素" class="headerlink" title="四、删除字典元素"></a>四、删除字典元素</h1><h2 id="1-del删除字典键值对"><a href="#1-del删除字典键值对" class="headerlink" title="1.del删除字典键值对"></a>1.del删除字典键值对</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------------------------------&quot;</span>)<br><span class="hljs-built_in">print</span>(dict3)<br><span class="hljs-keyword">del</span> dict3[<span class="hljs-string">&quot;age&quot;</span>]<br><span class="hljs-built_in">print</span>(dict3)<br><span class="hljs-comment">#输出</span><br><span class="hljs-comment">#&#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;age&#x27;: 12&#125;</span><br><span class="hljs-comment">#&#123;&#x27;name&#x27;: &#x27;tom&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-pop"><a href="#2-pop" class="headerlink" title="2.pop()"></a>2.pop()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------------------------------&quot;</span>)<br><span class="hljs-built_in">print</span>(dict3)<br>dict3.pop(<span class="hljs-string">&#x27;age&#x27;</span>)<br><span class="hljs-built_in">print</span>(dict3)<br><span class="hljs-built_in">print</span>(dict3.pop(<span class="hljs-string">&quot;age1&quot;</span>, <span class="hljs-string">&quot;不存在!&quot;</span>))<br><br><span class="hljs-comment">#&#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;age&#x27;: 12&#125;</span><br><span class="hljs-comment">#&#123;&#x27;name&#x27;: &#x27;tom&#x27;&#125;</span><br><span class="hljs-comment">#不存在!</span><br><span class="hljs-comment">#&#123;&#x27;name&#x27;: &#x27;tom&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>使用pop()可以定义当没有键的时候的返回值</p><h2 id="3-使用del删除整个字典"><a href="#3-使用del删除整个字典" class="headerlink" title="3.使用del删除整个字典"></a>3.使用del删除整个字典</h2><h2 id="4-使用clear-清空整个字典"><a href="#4-使用clear-清空整个字典" class="headerlink" title="4.使用clear()清空整个字典"></a>4.使用clear()清空整个字典</h2><h1 id="五、遍历字典"><a href="#五、遍历字典" class="headerlink" title="五、遍历字典"></a>五、遍历字典</h1><h2 id="1-直接遍历键"><a href="#1-直接遍历键" class="headerlink" title="1.直接遍历键"></a>1.直接遍历键</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dict3:<br>    <span class="hljs-built_in">print</span>(key, dict3[key])<br></code></pre></td></tr></table></figure><p>这样对字典进行遍历，只会遍历字典中的键，通过dict[key]进行取值</p><h2 id="2-通过dict-items-遍历"><a href="#2-通过dict-items-遍历" class="headerlink" title="2.通过dict.items()遍历"></a>2.通过dict.items()遍历</h2><p>items() 函数以列表返回可遍历的(键, 值) 元组数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(dict3.items())<br><span class="hljs-comment">#dict_items([(&#x27;name&#x27;, &#x27;tom&#x27;), (&#x27;age&#x27;, 12)])</span><br></code></pre></td></tr></table></figure><h1 id="六、字典与json互转"><a href="#六、字典与json互转" class="headerlink" title="六、字典与json互转"></a>六、字典与json互转</h1><h2 id="1-字典转化为json"><a href="#1-字典转化为json" class="headerlink" title="1.字典转化为json"></a>1.字典转化为json</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------------------------------------------------&quot;</span>)<br><span class="hljs-built_in">print</span>(dict3)<br><span class="hljs-built_in">print</span>(json.dumps(dict3))<br><span class="hljs-comment">#&#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;age&#x27;: 12&#125;</span><br><span class="hljs-comment">#&#123;&quot;name&quot;: &quot;tom&quot;, &quot;age&quot;: 12&#125;</span><br></code></pre></td></tr></table></figure><p>以这种方式将字典转化为json</p><h2 id="2-字典与json区别"><a href="#2-字典与json区别" class="headerlink" title="2.字典与json区别"></a>2.字典与json区别</h2><ul><li>json 中除数据外，key和value都是字符串，要用双引号引起来（就像上面字典转化成json后变为双引号）；空值写为null；布尔值为false&#x2F;true</li><li>字典中的key,value可单引号；空值为None；布尔值为False&#x2F;True(大写)</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 字典 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class中_init_()方法详解</title>
      <link href="/2022/09/17/Python/class%E4%B8%AD_init_()%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/09/17/Python/class%E4%B8%AD_init_()%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="init-详解"><a href="#init-详解" class="headerlink" title="__ init __()详解"></a>__ init __()详解</h1><h1 id="1-init-是什么"><a href="#1-init-是什么" class="headerlink" title="1._ init _()是什么"></a>1._ <em>init</em> _()是什么</h1><ul><li>跟java中类的构造函数类似。能够对类中成员进行初始化操作</li><li>在实例化时，可直接用类似构造函数的形式赋值</li></ul><p><strong>init()方法有两个方面的重大意义：</strong></p><p>​<strong>1. 在对象生命周期中初始化；每个对象必须正确初始化后才能正常工作。</strong></p><p>​<strong>2. init()参数值可以有多种形式。</strong></p><h1 id="2-代码实例"><a href="#2-代码实例" class="headerlink" title="2.代码实例"></a>2.代码实例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_id, name, age</span>):<br>        self.num_id = num_id<br>        self.name = name<br>        self.age = age<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_info</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.name)<br>        <span class="hljs-built_in">print</span>(self.age)<br><br><br>s1 = Student(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">21</span>)<br>s1.print_info()<br></code></pre></td></tr></table></figure><p>本人初学者，总结以下几点：</p><ul><li><p>init()函数不是必须要写的</p></li><li><p>定义的init()函数相当于java的构造函数，可直接像上述代码<code>s1 = Student(123, &quot;tom&quot;, 21)</code> 这样实例化使用。没有的话，就不能这样初始化赋值</p></li><li><p>以<code>self.num_id = num_id</code>为例。是没有强制要求等号前后的名称必须一致的。self.xxx这里是类中的成员变量，而等号后的xxx是传进来的参数。为了好记和增强可读性，才会如此。</p></li><li><p>另外，__ init() __函数在创建对象时，是自动调用的。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_id, name, age</span>):<br>        self.num_id = num_id<br>        self.name = name<br>        self.age = age<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span> + self.name + <span class="hljs-string">&quot;!&quot;</span>)<br><br>s1 = Student(<span class="hljs-number">123</span>, <span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">21</span>)<br>//输出<br>//hellotom!           <br></code></pre></td></tr></table></figure><p>在创建对象时，调用init()，打印了helloxxx。当然，实际中是不建议这样操作的，我们可以写一个方法来实现类似功能。</p><p>那么用或者不用__ init __的区别在哪里呢？</p><ul><li>当使用这个“构造函数”时，可以在创建对象时自动初始化。如果不用时，就只能通过对象.属性进行赋值操作了。</li><li>有构造函数初始化时，必须进行传值操作，否则就会报错。而无构造函数时，可以是一个空结构，随着输入赋值而添加相应数据</li></ul><p><strong>注：</strong>__ dict __  可打印所有成员变量的字典格式</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 类与对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用类</title>
      <link href="/2022/09/10/Java/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2022/09/10/Java/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h1><h1 id="一、内部类"><a href="#一、内部类" class="headerlink" title="一、内部类"></a>一、内部类</h1><p><strong>内部类概念：</strong> 在一个类的内部在定义一个完整的类</p><p><strong>特点：</strong></p><ul><li><p>编译之后可生成独立的字节码文件</p></li><li><p>内部类可直接访问外部类的私用成员，而不破坏封装</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Body</span>&#123;<br>    <span class="hljs-keyword">private</span>  String name;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Header</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>内部类可为外部类提供一些必要的内部功能组件</li></ul><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202209111845260.png" alt="image-20220910192710655" style="zoom:150%;" /><h2 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1. 成员内部类"></a><strong>1. 成员内部类</strong></h2><ul><li><p>一个类在另一个类当中，作为这个类的一个成员而存在</p></li><li><p>在类的内部定义，与实例变量、实例方法同级别的类</p></li><li><p>外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-comment">//实例变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;李四&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>;<br><br>    <span class="hljs-comment">//内部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;北京&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1111&quot;</span>;<br><br>        <span class="hljs-comment">//方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(name);<br>            System.out.println(age);<br>            System.out.println(address);<br>            System.out.println(phone);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        //1.创建外部类对象</span><br><span class="hljs-comment">//        Outer outer = new Outer();</span><br><span class="hljs-comment">//        //2.创建内部类对象</span><br><span class="hljs-comment">//        Outer.Inner inner = outer.new Inner();</span><br><span class="hljs-comment">//        inner.show();</span><br>        Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<span class="hljs-comment">//这样也可以</span><br>        inner.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202209111919563.png" alt="image-20220911191917434"></p><ul><li>当内部类与外部类属性变量重名时，首先访问的是内部类的变量。<ul><li>想访问外部类同名属性时，加入外部类 Class.this.name即可</li><li>当不重名时，也可以加上，调用更加明确，易懂</li></ul></li><li>成员内部类中不能定义静态成员<ul><li>即在内部类中定义 <code>private static String name = &quot;李四&quot;</code>  会报错</li><li>但是加上 <code>final</code> 就可以了，比较特殊    静态常量可以定义</li></ul></li></ul><h2 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a><strong>2. 静态内部类</strong></h2><ul><li><p>static   静态内部类</p></li><li><p>不依赖外部类对象，可直接创建或通过类名访问，可声明静态成员</p></li><li><p>外部类不能加static</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//外部类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sss&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br><br>    <span class="hljs-comment">//静态内部类，和外部类相同，同等地位</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner1</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;河南&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11111&quot;</span>;<br>        <span class="hljs-comment">//静态成员</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-comment">//1.调用外部类属性</span><br>            <span class="hljs-comment">//需要先创建外部类对象  把静态类看作和外部类平行的另一个外部类</span><br>            <span class="hljs-type">Outer1</span> <span class="hljs-variable">outer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer1</span>();<br>            System.out.println(outer1.name);<br>            System.out.println(outer1.age);<br><br>            <span class="hljs-comment">//2.调用静态内部类</span><br>            System.out.println(address);<br>            System.out.println(phone);<br><br>            <span class="hljs-comment">//3.调用静态类的静态属性</span><br>            <span class="hljs-comment">//通过类名.属性名调用</span><br>            System.out.println(Inner1.count);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//因为静态内部类与外部类地位相同，故直接创建内部类对象</span><br>        <span class="hljs-comment">//不需要像成员内部类那样先创建外部类对象</span><br>        <span class="hljs-comment">//以下Outer.Inner1  .仅表示包含所属关系  并没有new Outer1()</span><br>        Outer1.<span class="hljs-type">Inner1</span> <span class="hljs-variable">inner1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer1</span>.Inner1();<br>        <span class="hljs-comment">//调用放法</span><br>        inner1.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202209112048761.png" alt="image-20220911204821289"></p><h2 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3. 局部内部类"></a><strong>3. 局部内部类</strong></h2><ul><li>一个类定义在方法内部</li><li>定义在外部类方法中，作用范围和创建对象范围仅限于当前方法</li><li>局部内部类访问外部类当前方法中的局部变量时，无法保证变量的声明周期与自身相同，变量必须修饰为final<ul><li>jdk17以后 会自动加</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;小明&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//定义局部变量</span><br>       <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;深圳&quot;</span>;<br>       <span class="hljs-comment">//定义局部内部类</span><br>       <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>           <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;<br>           <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345@qq.com&quot;</span>;<br>           <span class="hljs-comment">//定义局部类的方法</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span>&#123;<br>               <span class="hljs-comment">//访问外部类的属性</span><br>               System.out.println(name);<br>               System.out.println(age);<br>               <span class="hljs-comment">//访问内部类属性</span><br>               System.out.println(phone);<br>               System.out.println(email);<br>               <span class="hljs-comment">//访问局部变量 jdk1.7时，要求变量必须是常量，之后版本可省略</span><br>               System.out.println(address);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">//如果没有以下两行代码，这样不会有任何输出结果</span><br>       <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>       inner.show2();<br>   &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        outer.show();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202209121257779.png" alt="image-20220912125750346"></p><h2 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4. 匿名内部类"></a><strong>4. 匿名内部类</strong></h2><ul><li>一种特殊内部类，没有名字，在使用接口和抽象类时使用</li><li>没有类名的局部内部类 （一切特征 与局部内部类相同）</li><li>必须继承一个父类，或者实现一个接口</li></ul><h1 id="二、Object类"><a href="#二、Object类" class="headerlink" title="二、Object类"></a>二、Object类</h1><ul><li>超类、基类，所有类的直接间接父类，位于继承树的最顶层</li><li>任何类，如果没有书写extends显示继承某个类，都默认继承的是Object类，否则为间接继承</li><li>Object类所定义的方法，为所有对象都具备的方法</li><li>Object 类型可以存储任何对象<ul><li>作为参数，接受任何对象 </li><li>作为返回值，可以返回任何对象</li></ul></li></ul><h2 id="1-getclass-方法"><a href="#1-getclass-方法" class="headerlink" title="1. getclass()方法"></a>1. getclass()方法</h2><p>返回引用中存储的实际对象类型。可以应用在判断两个引用中实际存储的对象类型是否一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">11</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-number">21</span>);<br>    <span class="hljs-comment">//System.out.println(s1.getClass());</span><br>    <span class="hljs-comment">//System.out.println(s2.getClass());</span><br>    <span class="hljs-keyword">if</span>(s1.getClass() == s2.getClass())<br>        System.out.println(<span class="hljs-string">&quot;同一个类型&quot;</span>);<br>&#125;<br><span class="hljs-comment">//输出为同一类型</span><br></code></pre></td></tr></table></figure><h2 id="2-hashCode-方法"><a href="#2-hashCode-方法" class="headerlink" title="2. hashCode()方法"></a>2. hashCode()方法</h2><ul><li>返回类型为int型</li><li>返回该对象的哈希码值</li><li>哈希值是根据对象的地址或字符串、数字使用hash算法计算出来的int型数值</li><li>一般请款下相同对象返回相同哈希码<ul><li>所以以此来判断两个对象是否为同一个</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">11</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小红&quot;</span>,<span class="hljs-number">21</span>);<br>    System.out.println(s1.hashCode());<br>    System.out.println(s2.hashCode());<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s2;<br>    System.out.println(s3.hashCode());<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-number">1915318863</span> <span class="hljs-comment">//s1</span><br><span class="hljs-number">1283928880</span> <span class="hljs-comment">//s2</span><br><span class="hljs-number">1283928880</span> <span class="hljs-comment">//s3</span><br></code></pre></td></tr></table></figure><p>由上可以看出 s2,s3是一个</p><h2 id="3-toString-方法"><a href="#3-toString-方法" class="headerlink" title="3. toString() 方法"></a>3. toString() 方法</h2><ul><li><p>返回类型为字符串形式</p></li><li><p>可以根据程序需求覆盖该方法(重写)</p></li><li><p>展示为包类名@地址</p></li></ul><p> &#x2F;&#x2F;记录快速生成方法快捷键 ： alt+insert</p><h2 id="4-eaquals-方法"><a href="#4-eaquals-方法" class="headerlink" title="4. eaquals()方法"></a>4. eaquals()方法</h2><ul><li>放回布尔类型</li><li>比较对象地址是否相同</li><li>对其进行重写，判断两个对象内容是否一致</li></ul><h2 id="5-finalize-方法"><a href="#5-finalize-方法" class="headerlink" title="5.finalize()方法"></a>5.finalize()方法</h2><ul><li>比较特殊，自己不会调用</li><li>当对象背判定为垃圾对象时，JVM自动调用 此方法，用以标记垃圾对象，进入回收队列</li><li>垃圾对象：没有有效引用指向此对象，为垃圾对象</li><li>垃圾回收：由GC销毁垃圾对象，释放数据存储空间</li></ul><h1 id="三、包装类"><a href="#三、包装类" class="headerlink" title="三、包装类"></a>三、包装类</h1><h2 id="1-包装类概述"><a href="#1-包装类概述" class="headerlink" title="1.包装类概述"></a>1.包装类概述</h2><p><strong>Java八个基本类型</strong>（四类八种）</p><ul><li><p>整型（4个）： byte、short、int、long</p></li><li><p>浮点型（2个）：float、double</p></li><li><p>字符（1个）： char</p></li><li><p>布尔类型:（1个）： boolean</p></li></ul><p>程序运行两个空间，一个堆，一个栈，基本类型都存在于栈中，引用类型数据在堆中。栈中存对象的地址</p><p><strong>包装类：</strong></p><ul><li>基本数据类型所对应的引用数据类型</li><li>Object可统一所有数据，包装类的默认值为null</li></ul><p><img src="https://raw.githubusercontent.com/zikers/image_store/main/img/202209152008480.png" alt="image-20220915200838013"></p><h2 id="2-类型转换和装箱、拆箱"><a href="#2-类型转换和装箱、拆箱" class="headerlink" title="2.类型转换和装箱、拆箱"></a>2.类型转换和装箱、拆箱</h2><p><strong>装箱</strong>：一个基本类型数据（在栈中），要把它转化为引用类型（放入堆中），这种转化操作叫做装箱</p><p><strong>拆箱</strong>：与上述装箱操作相反</p><p><strong>在jdk1.5之前，只能进行如下操作，进行装箱和拆箱，在jdk1.5之后，就可以进行自动装箱拆箱操作，使代码更加的简洁。</strong></p><p><em>jdk1.5之前：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//进行装箱：基本类型转化为引用类型的操作</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(num);<span class="hljs-comment">//方法1</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer1</span> <span class="hljs-operator">=</span> Integer.valueOf(num);<span class="hljs-comment">//方法2</span><br>        System.out.println(integer);<br>        System.out.println(integer1);<br><br>        System.out.println(<span class="hljs-string">&quot;-------------------------&quot;</span>);<br>        <br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//进行拆箱：将引用类型转化为基本类型</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> integer2.intValue();<br>        System.out.println(num1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>jdk1.5之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> num;<br><span class="hljs-type">int</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> integer2;<br></code></pre></td></tr></table></figure><p>直接这样复制即可，不用像之前那样调用方法。但是在运行时，是在动将方法调用了的。<strong>反汇编的代码和jdk1.5之前相同。</strong></p><p>自动装箱其实调用了 Integer.valueof()方法</p><h2 id="3-基本类型与字符串之间转换"><a href="#3-基本类型与字符串之间转换" class="headerlink" title="3.基本类型与字符串之间转换"></a>3.基本类型与字符串之间转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">//1.基本类型转化为字符串</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//方法1：直接加引号转变为字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> Integer.toString(n1);<span class="hljs-comment">//使用Integer封装的方法</span><br>        System.out.println(s1);<br>        System.out.println(s2);<br><br>        <span class="hljs-comment">//2.字符串转化为基本类型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;150&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(str);<span class="hljs-comment">//使用封装的parsexxx()方法</span><br>        System.out.println(num);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>其实转换时均是使用了包装类型里的方法。包装类型里提供了转化为其他类型的方法。</p><p><strong>特殊的布尔类型转换如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">//boolean字符串形式转化为基本类型 “true”--&gt;true  非true均转为false</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;true&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ture&quot;</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> Boolean.parseBoolean(s);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> Boolean.parseBoolean(s1);<br>        System.out.println(b);<br>        System.out.println(b1);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">//true</span><br><span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p><strong>总结：</strong> 当要转换的字符串为true时，其转换为布尔类型为true;当是除了true的其他字符串时，转换为布尔类型均为false。</p><h2 id="4-Integer缓冲区问题"><a href="#4-Integer缓冲区问题" class="headerlink" title="4.Integer缓冲区问题"></a>4.Integer缓冲区问题</h2><ul><li>Java预先创建了 256个常用的整数包装类型对象</li><li>在实际应用过程中，对已创建的对象进行复用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first-blog</title>
      <link href="/2022/09/10/first-blog/"/>
      <url>/2022/09/10/first-blog/</url>
      
        <content type="html"><![CDATA[<p>开始了自己的写博客之路。愿坚持不懈，学有所成。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
